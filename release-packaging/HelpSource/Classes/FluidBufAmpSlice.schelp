TITLE:: FluidBufAmpSlice
SUMMARY:: Amplitude-based Slicer for Buffers
CATEGORIES:: Libraries>FluidDecomposition
RELATED:: Guides/FluCoMa, Guides/FluidDecomposition

DESCRIPTION::
This class implements an amplitude-based slicer, with various customisable options and conditions to detect absolute and relative amplitude changes as onsets and offsets. It is part of the Fluid Decomposition Toolkit of the FluCoMa project.footnote::This was made possible thanks to the FluCoMa project ( http://www.flucoma.org/ ) funded by the European Research Council ( https://erc.europa.eu/ ) under the European Union’s Horizon 2020 research and innovation programme (grant agreement No 725899).::

FluidAmpSlice is based on two envelop followers on a highpassed version of the signal: one absolute, and one relative. Each have features that will interact, including independent Schmidt triggers and state-aware time contraints. The example code below is unfolding the various possibilites in order of complexity.

The process will return a two-channel buffer with the addresses of the onset on the first channel, and the address of the offset on the second channel.

CLASSMETHODS::

METHOD:: process
	This is the method that calls for the slicing to be calculated on a given source buffer.

ARGUMENT:: server
	The server on which the buffers to be processed are allocated.

ARGUMENT:: source
	The index of the buffer to use as the source material to be sliced through novelty identification. The different channels of multichannel buffers will be summed.

ARGUMENT:: startFrame
	Where in the srcBuf should the slicing process start, in sample.

ARGUMENT:: numFrames
	How many frames should be processed.

ARGUMENT:: startChan
	For multichannel sources, which channel should be processed.

ARGUMENT:: numChans
	For multichannel sources, how many channel should be summed.

ARGUMENT:: indices
	The index of the buffer where the indices (in sample) of the estimated starting points of slices will be written. The first and last points are always the boundary points of the analysis.

ARGUMENT:: absRampUp
	The number of samples the absolute envelope follower will take to reach the next value when raising.

ARGUMENT:: absRampDown
	The number of samples the absolute envelope follower will take to reach the next value when falling.

ARGUMENT:: absThreshOn
	The threshold in dB of the absolute envelope follower to trigger an onset, aka to go ON when in OFF state.

ARGUMENT:: absThreshOff
	The threshold in dB of the absolute envelope follower to trigger an offset, , aka to go ON when in OFF state.

ARGUMENT:: minSliceLength
	The length in samples that the Slice will stay ON. Changes of states during that period will be ignored.

ARGUMENT:: minSilenceLength
	The length in samples that the Slice will stay OFF. Changes of states during that period will be ignored.

ARGUMENT:: minLengthAbove
	The length in samples that the absolute envelope have to be above the threshold to consider it a valid transition to ON. The Slice will start at the first sample when the condition is met. Therefore, this affects the latency.

ARGUMENT:: minLengthBelow
	The length in samples that the absolute envelope have to be below the threshold to consider it a valid transition to OFF. The Slice will end at the first sample when the condition is met. Therefore, this affects the latency.

ARGUMENT:: lookBack
	The length of the buffer kept before an onset to allow the algorithm, once a new Slice is detected, to go back in time (up to that many samples) to find the minimum amplitude as the Slice onset point. This affects the latency of the algorithm.

ARGUMENT:: lookAhead
	The length of the buffer kept after an offset to allow the algorithm, once the Slice is considered finished, to wait further in time (up to that many samples) to find a minimum amplitude as the Slice offset point. This affects the latency of the algorithm.

ARGUMENT:: relRampUp
	The number of samples the relative envelope follower will take to reach the next value when raising. Typically, this will be faster than absRampUp.

ARGUMENT:: relRampDown
	The number of samples the relative envelope follower will take to reach the next value when falling. Typically, this will be faster than absRampDown.

ARGUMENT:: relThreshOn
	The threshold in dB of the relative envelope follower to trigger an onset, aka to go ON when in OFF state. It is computed on the difference between the two envelope followers.

ARGUMENT:: relThreshOff
	The threshold in dB of the relative envelope follower to reset, aka to allow the differential envelop to trigger again.

ARGUMENT:: highPassFreq
	The frequency of the fourth-order Linkwitz–Riley high-pass filter (https://en.wikipedia.org/wiki/Linkwitz%E2%80%93Riley_filter). This is done first on the signal to minimise low frequency intermodulation with very fast ramp lengths.

ARGUMENT:: outputType
(describe argument here)

ARGUMENT:: action
	A Function to be evaluated once the offline process has finished and indices instance variables have been updated on the client side. The metric will be passed indices as an argument.

RETURNS::
	Nothing, as the destination buffer is declared in the function call.

EXAMPLES::

code::
//basic tests: highPass sanity
(
{var env, source = SinOsc.ar(320,0,0.5);
	env = FluidAmpSlice.ar(source,highPassFreq:250, outputType:1);
	[source, env]
}.plot(0.03);
)
//basic tests: absRampUp-Down sanity
(
	{var env, source = SinOsc.ar(320,0,0.5);
		env = FluidAmpSlice.ar(source,absRampUp:10, absRampDown:1000, outputType:2);
		[source.abs, env]
	}.plot(0.03);
)
/////////////////////////////
//basic tests: absThresh sanity
(
    {var env, source = SinOsc.ar(320,0,LFTri.ar(10).abs);
	env = FluidAmpSlice.ar(source,absRampUp:10, absRampDown:100, absThreshOn:-12, absThreshOff: -12);
        [source, env]
    }.plot(0.1);
)
//basic tests: absThresh histeresis
(
    {var env, source = SinOsc.ar(320,0,LFTri.ar(10).abs);
	env = FluidAmpSlice.ar(source,absRampUp:10, absRampDown:100, absThreshOn:-12, absThreshOff: -16);
        [source, env]
    }.plot(0.1);
)
//basic tests: absThresh min slice
(
    {var env, source = SinOsc.ar(320,0,LFTri.ar(10).abs);
	env = FluidAmpSlice.ar(source,absRampUp:10, absRampDown:100, absThreshOn:-12, absThreshOff: -12, minSliceLength:441);
        [source, env]
    }.plot(0.1);
)
//basic tests: absThresh min silence
(
    {var env, source = SinOsc.ar(320,0,LFTri.ar(10).abs);
	env = FluidAmpSlice.ar(source,absRampUp:10, absRampDown:100, absThreshOn:-12, absThreshOff: -12, minSilenceLength:441);
        [source, env]
    }.plot(0.1);
)
//mid tests: absThresh time histeresis on
(
    {var env, source = SinOsc.ar(320,0,LFTri.ar(10).abs);
	env = FluidAmpSlice.ar(source,absRampUp:10, absRampDown:100, absThreshOn:-12, absThreshOff: -12, minLengthAbove:441, outputType:0);
				[DelayN.ar(source,0.1,441/44100), env]
    }.plot(0.1);
)
//mid tests: absThresh time histeresis off
(
    {var env, source = SinOsc.ar(320,0,LFTri.ar(10).abs);
	env = FluidAmpSlice.ar(source,absRampUp:10, absRampDown:100, absThreshOn:-12, absThreshOff: -12, minLengthBelow:441);
        [DelayN.ar(source,0.1,441/44100), env]
    }.plot(0.1);
)
//mid tests: absThresh with lookBack
(
    {var env, source = SinOsc.ar(320,0,LFTri.ar(10).abs);
	env = FluidAmpSlice.ar(source,absRampUp:10, absRampDown:100, absThreshOn:-12, absThreshOff: -12,lookBack:441);
        [DelayN.ar(source,0.1,441/44100), env]
    }.plot(0.1);
)
//mid tests: absThresh with lookAhead
(
    {var env, source = SinOsc.ar(320,0,LFTri.ar(10).abs);
	env = FluidAmpSlice.ar(source,absRampUp:10, absRampDown:100, absThreshOn:-12, absThreshOff: -12,lookAhead:441);
        [DelayN.ar(source,0.1,441/44100), env]
    }.plot(0.1);
)
//mid tests: absThresh with asymetrical lookBack and lookAhead
(
    {var env, source = SinOsc.ar(320,0,LFTri.ar(10).abs);
	env = FluidAmpSlice.ar(source,absRampUp:10, absRampDown:100, absThreshOn:-12, absThreshOff: -12,lookBack:221, lookAhead:441);
        [DelayN.ar(source,0.1,441/44100), env]
    }.plot(0.1);
)
//advanced tests: absThresh histeresis, long tail
(
    {var env, source = SinOsc.ar(320,0,LFTri.ar(10).abs);
	env = FluidAmpSlice.ar(source,absRampUp:10, absRampDown:2000, absThreshOn:-12, absThreshOff: -16);
        [source, env]
    }.plot(0.1);
)
//solution: have to recut with relThresh
(
    {var env, source = SinOsc.ar(320,0,LFTri.ar(10).abs);
	env = FluidAmpSlice.ar(source,absRampUp:10, absRampDown:2000, absThreshOn:-12, absThreshOff: -16, relRampUp:5, relRampDown:200, relThreshOn:-1, relThreshOff:-12);
        [source, env]
    }.plot(0.1);
)
//beware of double trig
(
    {var env, source = SinOsc.ar(320,0,LFTri.ar(10).abs);
	env = FluidAmpSlice.ar(source,absRampUp:10, absRampDown:2000, absThreshOn:-12, absThreshOff: -16, relRampUp:5, relRampDown:200, relThreshOn:-1, relThreshOff:-1);
        [source, env]
    }.plot(0.05);
)
//a solution: minSliceLength
(
    {var env, source = SinOsc.ar(320,0,LFTri.ar(10).abs);
	env = FluidAmpSlice.ar(source,absRampUp:10, absRampDown:2000, absThreshOn:-12, absThreshOff: -16, relRampUp:5, relRampDown:200, relThreshOn:-1, relThreshOff:-1, minSliceLength:441);
        [source, env]
    }.plot(0.05);
)
//drum slicing, many ways
//load a buffer
b = Buffer.read(s,File.realpath(FluidAmpSlice.class.filenameSymbol).dirname.withTrailingSlash ++ "../AudioFiles/Nicol-LoopE-M.wav");
(
			{var env, source = PlayBuf.ar(1,b);
	env = FluidAmpSlice.ar(source,absRampUp:2205, absRampDown:2205, absThreshOn:-70, absThreshOff: -80, relRampUp:10, relRampDown:441, relThreshOn:14, relThreshOff:12, minSliceLength:4410, outputType:0);
        [source, env]
			}.plot(2,maxval:[1,1],separately:true);
)

(
			{var env, source = PlayBuf.ar(1,b);
				env = FluidAmpSlice.ar(source,highPassFreq:120, absRampUp:2205, absRampDown:2205, absThreshOn:-70, absThreshOff: -80, relRampUp:10, relRampDown:2205, relThreshOn:12, relThreshOff:8, minSliceLength:441);
        [source, env]
			}.play);
)
::

STRONG::A stereo buffer example.::
CODE::
// make a stereo buffer
b = Buffer.alloc(s,88200,2);

// add some stereo clicks and listen to them
((0..3)*22050+11025).do({|item,index| b.set(item+(index%2), 1.0)})
b.play

// create a new buffer as destinations
c = Buffer.new(s);

//run the process on them
(
// with basic params
Routine{
    t = Main.elapsedTime;
    FluidBufAmpSlice.process(s,b, indices: c);
    (Main.elapsedTime - t).postln;
}.play
)

// list the indicies of detected attacks - the two input channels have been summed
c.getn(0,c.numFrames,{|item|item.postln;})
::
