TITLE:: FluidNormalize
summary:: Normalize a FluidDataSet
categories:: FluidManipulation
related:: Classes/FluidStandardize, Classes/FluidDataSet

DESCRIPTION::
Normalize the entries of a link::Classes/FluidDataSet::, or normalize a data point according to the learned bounds of a data set. On the server.

See http://www.faqs.org/faqs/ai-faq/neural-nets/part2/section-16.html

CLASSMETHODS::

private:: kr

METHOD:: new
Create a new instance
ARGUMENT:: server
The link::Classes/Server:: on which to run
ARGUMENT:: min
Minimum output value, default 0
ARGUMENT:: max
Maximum output value, default 1


INSTANCEMETHODS::

METHOD:: fit
Compute the normalization factors from a link::Classes/FluidDataSet:: for later.
ARGUMENT:: dataset
The link::Classes/FluidDataSet:: to normalize
ARGUMENT:: action
A function to run when processing is complete

METHOD:: transform
Normalize a link::Classes/FluidDataSet:: into another link::Classes/FluidDataSet::, using the learned extrema from a previous call to link::Classes/FluidNormalize#fit::
ARGUMENT:: sourceDataset
The link::Classes/FluidDataSet:: to normalize
ARGUMENT:: destDataset
The link::Classes/FluidDataSet:: to populate with normalized data
ARGUMENT:: action
A function to run when processing is complete


METHOD:: fitTransform
Normalize a link::Classes/FluidDataSet::
ARGUMENT:: sourceDataset
The link::Classes/FluidDataSet:: to normalize
ARGUMENT:: destDataset
The link::Classes/FluidDataSet:: to populate with normalized data
ARGUMENT:: action
A function to run when processing is complete


METHOD:: transformPoint
Normalize a new data point, using the learned extrema from a previous call to link::Classes/FluidNormalize#fit::
ARGUMENT:: sourceBuffer
A link::Classes/Buffer:: with the new data point
ARGUMENT:: destBuffer
A link::Classes/Buffer:: to contain the normalized value
ARGUMENT:: action
A function to run when processing is complete

EXAMPLES::
code::
s.boot;
//Preliminaries: we want some audio, a couple of FluidDataSets, some Buffers and a FluidNormalize
(
~audiofile = File.realpath(FluidBufPitch.class.filenameSymbol).dirname +/+ "../AudioFiles/Tremblay-ASWINE-ScratchySynth-M.wav";
~raw = FluidDataSet(s,\norm_help_raw);
~norm = FluidDataSet(s,\norm_help_normd);
~audio = Buffer.read(s,~audiofile);
~pitch_feature = Buffer.new(s);
~stats = Buffer.new(s);
~datapoint = Buffer.alloc(s,2);
~normalizer = FluidNormalize(s);
)

// Do a pitch analysis on the audio, which gives us pitch and pitch confidence (so a 2D datum)
// Divide the time series in to 10, and take the mean of each segment and add this as a point to
// the 'raw' FluidDataSet
(
~raw.clear;
~norm.clear;
FluidBufPitch.process(s,~audio,features:~pitch_feature,action:{
	"Pitch analysis.complete. Doing stats".postln;
	fork{
		var chunkLen = (~pitch_feature.numFrames / 10).asInteger;
		10.do{ |i|
			s.sync;	FluidBufStats.process(s,~pitch_feature,startFrame:i*chunkLen,numFrames:chunkLen,stats:~stats, action:{
			~stats.loadToFloatArray(action:{ |statsdata|
					[statsdata[0],statsdata[1]].postln;
					~datapoint.setn(0,[statsdata[0],statsdata[1]]);
					s.sync;
					("Adding point" ++ i).postln;
					~raw.addPoint(i,~datapoint);
				})
			});
			if(i == 9) {"Analysis done, dataset ready".postln}
		}
	}
});
)

//Fit the FluidNormalizer to the raw data, and then apply the scaling out of place into
//our second FluidDataSet, so we can compare.
//Download the dataset contents into arrays for plotting
(
~normalizer.fit(~raw);
~normalizer.transform(~raw,~norm);
~rawarray = Array.new(10);
~normedarray= Array.new(10);
fork{
	10.do{|i|
		~raw.getPoint(i,~datapoint,{
			~datapoint.loadToFloatArray(action:{|a| ~rawarray.add(Array.newFrom(a))})
		});
		s.sync;
		~norm.getPoint(i,~datapoint,{

			~datapoint.loadToFloatArray(action:{|a| ~normedarray.add(Array.newFrom(a))})
		});
		s.sync;
		if(i==9){"Data downloaded".postln};
	}
}
)
//Plot side by side. Before normalization the two dimensions have radically different scales
//which can be unhelpful in many cases
(
~rawarray.flatten(1).unlace.plot("Unnormalized",Rect(0,0,400,400),minval:0,maxval:[5000,1]).plotMode=\bars;
~plot2 = ~normedarray.flatten(1).unlace.plot("Normalized",Rect(410,0,400,400)).plotMode=\bars;
)
::
